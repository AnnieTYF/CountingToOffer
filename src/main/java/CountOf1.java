public class CountOf1 {
    /**
     * 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
     * 1~13中包含1的数字有1、10、11、12、13因此共出现6次
     * 可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
     *
     * ...这种题真的是考数学啊。。不是很想做，因为涉及到很多找规律和归纳
     *
     * 将原数字按10的倍数进行分割，求个、十、百....位上1的个数。以a=31415 and
     * b=92为例，讨论百位上1的个数，由于5是大于1的，所以当百位上出现1时，个位、十位的范围是0—99，
     * 所以此时乘以100，而5的前面可以是0
     * -3141，总共（3141+1）=3142个。然而当所求位上为0和1时，其后面的位上不一定能达到0-99，这时候就考虑减1操作。
     * 我大概就是这样理解的。
     */
    public int NumberOf1Between1AndN_Solution(int n) {
        if(n <= 0)
            return 0;
        int count = 0;
        for(long i = 1; i <= n; i *= 10){
            long diviver = i * 10;
            count += (n / diviver) * i + Math.min(Math.max(n % diviver - i + 1, 0), i);
        }
        return count;
    }


    /**
     * 解法一：
     * 思路是分别计算个位、十位、百位........上出现 1 的个数。
     * 以  n =216为例：
     * 个位上： 1 ，11，21，31，.....211。个位上共出现（216/10）+ 1个 1 22个
     * 因为除法取整，210~216间个位上的1取不到，所以我们加8进位。你可能说为什么不加9，n=211怎么办，
     * 这里把最后取到的个位数为1的单独考虑，先往下看。
     * 十位上：10~19，110~119，210~216.   十位上可看成 求（216/10）=21 27个
     * 百位上 100 - 199  100 个
     * 个位上的1的个数然后乘10。这里再次把最后取到的十位数为1的单独拿出来，即210~216要单独考虑 ，个数为（216%10）+1
     * 这里加8就避免了判断的过程。
     * 后面以此类推。
     * 时间复杂度 O(logN)
     * @param n
     * @return
     */
    public static int NumberOf1Between1AndN_Solution2(int n) {
        int cnt = 0;
        for (int m = 1; m <= n; m *= 10) {
            int a = n / m, b = n % m;
            //10~216 十位上要多加7个1
            //之所以补8，是因为当位置为0，则a/10==(a+8)/10，当位置>=2，补8会产生进位位，效果等同于(a/10+1)
            cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
        }
        return cnt;
    }

    public static void main(String args[]){
        System.out.println(NumberOf1Between1AndN_Solution2(216));
    }



}
